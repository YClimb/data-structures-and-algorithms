package sort;

/**
 * 排序总结
 *
 * @author yclimb
 * @date 2020/9/10
 */
public class Sorts {
    public static void main(String[] args) {
        /**
         * 冒泡排序：前后比较相邻元素，满足大小关系则替换
         * 插入排序：数组分为已排序和未排序区间，每次取未排序区间的一个数字去和已排序区间比较，并插入合适的位置，后面数字依次往后移一位，直到未排序无
         * 选择排序：数组分为已排序和未排序区间，每次取未排序区间最小的数字，放在已排序的末尾，直到未排序无
         * 快速排序：分治递归思想，选取数组中任意一个数字为分区点，将数组分为小于分区点的区间和大于分区点的区间，各自排序之后，最终结果为顺序排列
         * 归并排序：将数组以中心点（一般为lenth/2）分隔为两半，各自排序左右区间；递归以上过程，直到两两排序完成，之后将排序的区间进行合并并排序，最终为顺序排列
         * 桶排序：将数组分为多个桶，如1-10，20-30，30-40，循环数组，将数组依次赋予桶并比较放入桶内相应位置，最终为顺序排列
         * 计数排序：特殊的桶排序，桶数量=分析数据长度，如：数组有100个数字，值为1-10之间，那么可以设置桶数量=10，循环100个数字依次放入10个桶中，最终为顺序排列
         * 线性排序：桶排序[BucketSort]、计数排序[CountingSort]、基数排序[RadixSort]（之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。）
         * 堆排序：堆顶元素是最大的，每次取堆顶的元素，并将数组中最后一个元素放于堆顶，进行堆化树结构，之后堆顶元素又变成最大的值；再次重复取堆顶元素这个过程，直到剩余最后一个值排序就完成了。
         *
         *
         * 时间复杂度是 O(n2) 的：冒泡排序、插入排序、选择排序；
         * 时间复杂度是 O(n) 的：桶排序[BucketSort]、计数排序[CountingSort]、基数排序[RadixSort]。
         * 时间复杂度是 O(nlogn) 的：归并排序、快速排序、线性排序，还有堆排序。
         *
         * 原地排序：所谓“原地”就是，不借助另一个数组，就在原数组上操作（是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序）。
         * 属于原地排序的是：冒泡排序、插入排序、选择排序、堆排序、快速排序、希尔排序。
         *
         * 稳定排序：在排序时不改变其序列，则称所用的方法是稳定的。如 1、1、2、3；排序之后1、1不改变下标，则表示稳定排序。
         * 是稳定排序：冒泡排序、插入排序、归并排序、计数排序、基数排序。
         * 不是稳定排序：选择排序、快速排序、希尔排序、堆排序。
         *
         */
    }
}
