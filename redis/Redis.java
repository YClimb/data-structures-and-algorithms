package redis;

/**
 * Redis 非关系型数据库：常用数据类型的数据结构
 *
 * @author yclimb
 * @date 2020/9/25
 */
public class Redis {
    /**
     * https://time.geekbang.org/column/article/79159
     *
     * Redis 中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让 Redis 的读写效率非常高。
     * 除此之外，Redis 主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。
     *
     * 数据类型：
     * 1.字符串（string）
     * 1.1.最简单的一种数据类型，对应数据结构也是字符串。
     *
     *
     * 2.列表（list）
     * 2.1.压缩列表（ziplist）
     * 当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：
     * 2.1.1.列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；
     * 2.1.2.列表中数据个数少于 512 个。
     * 压缩列表并不是基础数据结构，他是 redis 自己设计的，它跟数组不同的一点是：它允许存储的数据大小不同，可以节省空间。
     *
     * 2.2.双向循环链表
     * 当列表中存储的数据量比较大的时候，也就是不能同时满足 ziplist 两个条件的时候，列表就要通过双向循环链表来实现了。
     * Redis 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个 list 结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。
     *
     *
     * 3.字典（hash）
     * 字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的压缩列表，另一种是散列表。
     * 3.1.压缩列表
     * 同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：
     * 3.1.1.字典中保存的键和值的大小都要小于 64 字节；
     * 3.1.2.字典中键值对的个数要小于 512 个。
     *
     * 3.2.散列表
     * 当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。
     * Redis 使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。
     * 3.2.1.当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右。
     * 3.2.2.当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小。
     * 我们前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis 使用我们在散列表（中）讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。
     * 渐进式扩容缩容策略：先新建一个新散列表 M，旧的散列表为 N，插入时直接插入 M 表，并 将 N 表部分数据搬运到 M 表，查询时先查 M 表，没找到再查 N 表，直到 N 表数据全部搬完即可删除 N 表。
     *
     *
     * 4.集合（set）
     * 集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。
     * 4.1.有序数组
     * 当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。
     * 4.1.1.存储的数据都是整数；
     * 4.1.2.存储的数据元素个数不超过 512 个。
     *
     * 4.2.散列表
     * 当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。
     *
     *
     * 5.有序集合（sortedset）
     * 有序集合这种数据类型，它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。
     * 有序集合也有两种存储结构，一种是基于压缩列表，一种是基于跳表。
     * 5.1.压缩列表
     * 使用压缩列表来实现有序集合的前提，有这样两个：
     * 5.1.1.所有数据的大小都要小于 64 字节；
     * 5.1.2.元素个数要小于 128 个。
     *
     * 5.2.跳表
     * 当不能同时满足上面两个条件的情况下，就使用跳表来存储数据。
     *
     *
     *
     * 数据结构持久化
     * 尽管 Redis 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。
     * 这样，当机器断电的时候，存储在 Redis 中的数据也不会丢失。
     * 在机器重新启动之后，Redis 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。
     *
     * 如何将数据结构持久化到硬盘？我们主要有两种解决思路。
     * 1.清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。
     * 不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。
     * 比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了。
     * 2.保留原来的存储格式，将数据按照原有的格式存储在磁盘中。
     * 我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。
     *
     *
     * 为什么要用压缩列表呢？
     * 1.压缩列表不支持随机访问。有点类似链表。但是比较省存储空间。Redis一般都是通过key获取整个value的值，也就是整个压缩列表的数据，并不需要随机访问。
     * 2.压缩列表需要像链表一样去遍历查询元素，所以不能太大。
     * 3.压缩列表非常小，数据结构中，越小越有利于CPU缓存。
     *
     *
     */
}
