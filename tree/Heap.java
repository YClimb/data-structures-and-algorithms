package tree;

/**
 * 堆
 *
 * @author yclimb
 * @date 2020/9/10
 */
public class Heap {
    public static void main(String[] args) {
        /**
         * https://time.geekbang.org/column/article/69913
         * https://github.com/wangzheng0822/algo/tree/master/java/28_sorts
         * 堆是一种特殊的树
         * 堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。
         *
         * 什么样的树才是堆。我罗列了两点要求，只要满足这两点，它就是一个堆。
         * 1.堆是一个完全二叉树；
         * 2.堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
         * 对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。
         *
         * 如何实现一个堆？
         * 1.因为堆是一个完全二叉树，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。
         * 2.数组从下标1开始存储，数组中下标为 i 的节点的左子节点，就是下标为 i*2 的节点，右子节点就是下标为 i*2+1 的节点，父节点就是下标为 2/i​ 的节点。
         *
         * 插入数据和删除堆顶元素的主要逻辑就是堆化（heapify），所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。
         * 堆化实际上有两种，从下往上和从上往下。
         * 堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。
         *
         */

        /**
         * 堆结构：
         * 1.堆是一个完全二叉树；
         * 2.堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
         *
         * 堆实现：
         * 1.因为堆是一个完全二叉树，完全二叉树比较适合用数组来存储。
         * 2.数组从下标1开始存储，数组中下标为 i 的节点的左子节点，就是下标为 i*2 的节点，右子节点就是下标为 i*2+1 的节点，父节点就是下标为 2/i​ 的节点。
         *
         * 堆排序
         * 1.堆顶元素是最大的，每次取堆顶的元素，并将数组中最后一个元素放于堆顶，进行堆化树结构，之后堆顶元素又变成最大的值；
         * 2.再次重复取堆顶元素这个过程，直到剩余最后一个值排序就完成了。
         *
         */

        /**
         * https://time.geekbang.org/column/article/70187
         * 堆的应用
         * 堆这种数据结构几个非常重要的应用：优先级队列、求 Top K 和求中位数。
         *
         * 1.堆的应用一：优先级队列
         * 优先级队列，顾名思义，它首先应该是一个队列。我们前面讲过，队列最大的特性就是先进先出。
         * 不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。
         * 如何实现一个优先级队列呢？方法有很多，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。
         * 依赖优先级队列的有：赫夫曼编码、图的最短路径、最小生成树算法等等，Java 的 PriorityQueue，C++ 的 priority_queue 等。
         * 1.1. 合并有序小文件
         * 1.2. 高性能定时器
         *
         * 2.堆的应用二：利用堆求 Top K
         * 2.1.一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。
         * 2.2.另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。
         * 求topk需要用到小顶堆（堆顶元素存k中最小的值，每次大于他则替换），求buttonk需要用到大顶堆（堆顶元素存k中最大值，每次小于他则替换）；
         *
         * 3.堆的应用三：利用堆求中位数
         * 3.1.静态数据，我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。
         * 3.1.动态数据，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：
         * 如果 n 是偶数，两个堆中的数据个数都是 2n​；如果 n 是奇数，大顶堆有 2n​+1 个数据，小顶堆有 2n​ 个数据。
         * 这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。
         *
         * 实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。大顶堆存储99%*n，小顶堆存储1%*n，大顶堆堆顶的数据就是我们要找的 99% 响应时间。
         *
         *
         */
    }
}
