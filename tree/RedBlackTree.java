package tree;

/**
 * 红黑树
 *
 * @author yclimb
 * @date 2020/9/10
 */
public class RedBlackTree {
    public static void main(String[] args) {
        /**
         * https://time.geekbang.org/column/article/68976
         * 什么是“平衡二叉查找树”？
         * 平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。
         * 从这个定义来看，我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。
         *
         * 红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树
         * 顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：
         * 1.根节点是黑色的；
         * 2.每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
         * 3.任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
         * 4.每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
         *
         * 左旋（rotate left）
         * 围绕某个节点的左旋，简单理解：将当前节点的右节点移动到当前节点位置，当前节点作为右节点的左子节点，右节点的子右节点依次上移，右节点的子左节点作为当前节点的子右节点
         *
         * 右旋（rotate right）
         * 围绕某个节点的右旋，简单理解：将当前节点的左节点移动到当前节点位置，当前节点作为左节点的右子节点，左节点的子左节点依次上移，左节点的子右节点作为当前节点的子左节点
         *
         *
         */

        /**
         * 动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，我们前面还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？
         *
         * 散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。
         * 跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。
         * 红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。
         */
    }
}
