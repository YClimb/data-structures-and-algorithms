package queue;

/**
 * 内存消息队列：无锁的并发循环消息队列(Disruptor)
 *
 * @author yclimb
 * @date 2020/9/25
 */
public class Disruptor {
    /**
     * https://time.geekbang.org/column/article/79871
     *
     * Disruptor 是一种内存消息队列。从功能上讲，它其实有点儿类似 Kafka。
     * 不过，和 Kafka 不同的是，Disruptor 是线程之间用于消息传递的队列。它在 Apache Storm、Camel、Log4j 2 等很多知名项目中都有广泛应用。
     *
     * 之所以如此受青睐，主要还是因为它的性能表现非常优秀。
     * 它比 Java 中另外一个非常常用的内存消息队列 ArrayBlockingQueue（ABS）的性能，要高一个数量级，可以算得上是最快的内存消息队列了。
     * 它还因此获得过 Oracle 官方的 Duke 大奖。
     *
     *
     * “生产者 - 消费者模型”
     * 一种简单的模型，生产者负责生产需求，消费者负责消费需求，按生产-消费的先后顺序执行。
     * 简单来说，可以使用队列来实现，队列基础是先进先出，所以可以满足这个模型的存储结构。
     *
     * 基于无锁的并发“生产者 - 消费者模型”
     * 尽管 Disruptor 的源码读起来很复杂，但是基本思想其实非常简单。实际上，它是换了一种队列和“生产者 - 消费者模型”的实现思路。
     * 一般队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的 add() 函数和 poll() 函数，而 Disruptor 采用了另一种实现思路。
     *
     *
     * Disruptor 的实现思路：
     * 1.对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的 n 个（n≥1）存储单元。
     * 当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。
     * 不过，从刚刚的描述中，我们可以看出，申请存储单元的过程是需要加锁的。
     *
     * 2.对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。
     * 不过，还有一个需要特别注意的地方，那就是，如果生产者 A 申请到了一组连续的存储单元，
     * 假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，那在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的。这个也是 Disruptor 实现思路的一个弊端。
     *
     * 实际上，Disruptor 采用的是 RingBuffer 和 AvailableBuffer 这两个结构，来实现我刚刚讲的功能。不过，因为我们主要聚焦在数据结构和算法上，所以我对这两种结构做了简化，但是基本思想是一致的。
     *
     *
     * 总结：
     * 为了在保证逻辑正确的前提下，尽可能地提高队列在并发情况下的性能，Disruptor 采用了“两阶段写入”的方法。
     * 在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。
     * Disruptor 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。
     *
     */
}
