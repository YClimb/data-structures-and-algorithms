package array;

/**
 * 散列表
 *
 * @author yclimb
 * @date 2020/9/7
 */
public class HashTable {
    public static void main(String[] args) {
        /**
         * https://time.geekbang.org/column/article/64233
         * https://github.com/wangzheng0822/algo/tree/master/java/18_hashtable
         * 散列表:散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。
         * 可以说，如果没有数组，就没有散列表。
         *
         * 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。
         * 我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。
         * 当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。
         *
         * 散列冲突解决办法：
         * 1.开放寻址法，出现冲突后，依次往后查找空白地址（线性探测、二次探测、双重散列）
         * 2.链表法，出现冲突后，插入链表
         */

        /**
         * 1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
         *
         * 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。
         * 如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。
         *
         *
         * 2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
         *
         * 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。
         * 再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。
         */
    }
}
